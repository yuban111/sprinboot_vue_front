var Yt=Object.defineProperty;var Zt=(f,e,i)=>e in f?Yt(f,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):f[e]=i;var b=(f,e,i)=>(Zt(f,typeof e!="symbol"?e+"":e,i),i),Lt=(f,e,i)=>{if(!e.has(f))throw TypeError("Cannot "+i)};var t=(f,e,i)=>(Lt(f,e,"read from private field"),i?i.call(f):e.get(f)),d=(f,e,i)=>{if(e.has(f))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(f):e.set(f,i)},a=(f,e,i,s)=>(Lt(f,e,"write to private field"),s?s.call(f,i):e.set(f,i),i);var Et=(f,e,i,s)=>({set _(h){a(f,e,h,i)},get _(){return t(f,e,s)}}),o=(f,e,i)=>(Lt(f,e,"access private method"),i);const ft=typeof performance=="object"&&performance&&typeof performance.now=="function"?performance:Date,Bt=new Set,xt=typeof process=="object"&&process?process:{},$t=(f,e,i,s)=>{typeof xt.emitWarning=="function"?xt.emitWarning(f,e,i,s):console.error(`[${i}] ${e}: ${f}`)};let Rt=globalThis.AbortController,Ht=globalThis.AbortSignal;var Vt;if(typeof Rt>"u"){Ht=class{constructor(){b(this,"onabort");b(this,"_onabort",[]);b(this,"reason");b(this,"aborted",!1)}addEventListener(s,h){this._onabort.push(h)}},Rt=class{constructor(){b(this,"signal",new Ht);e()}abort(s){var h,n;if(!this.signal.aborted){this.signal.reason=s,this.signal.aborted=!0;for(const r of this.signal._onabort)r(s);(n=(h=this.signal).onabort)==null||n.call(h,s)}}};let f=((Vt=xt.env)==null?void 0:Vt.LRU_CACHE_IGNORE_AC_WARNING)!=="1";const e=()=>{f&&(f=!1,$t("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e))}}const Jt=f=>!Bt.has(f),et=f=>f&&f===Math.floor(f)&&f>0&&isFinite(f),qt=f=>et(f)?f<=Math.pow(2,8)?Uint8Array:f<=Math.pow(2,16)?Uint16Array:f<=Math.pow(2,32)?Uint32Array:f<=Number.MAX_SAFE_INTEGER?zt:null:null;class zt extends Array{constructor(e){super(e),this.fill(0)}}var ct;const rt=class rt{constructor(e,i){b(this,"heap");b(this,"length");if(!t(rt,ct))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new i(e),this.length=0}static create(e){const i=qt(e);if(!i)return[];a(rt,ct,!0);const s=new rt(e,i);return a(rt,ct,!1),s}push(e){this.heap[this.length++]=e}pop(){return this.heap[--this.length]}};ct=new WeakMap,d(rt,ct,!1);let Ut=rt;var N,L,P,H,ut,dt,T,k,F,m,g,R,x,C,O,V,E,B,$,U,q,ht,W,mt,Mt,ot,K,bt,M,Wt,Xt,lt,gt,yt,Y,it,Z,st,At,Gt,Kt,pt,vt,wt,Ct,p,_,Ft,It,at,_t,J,nt,Tt,jt;const Nt=class Nt{constructor(e){d(this,mt);d(this,Wt);d(this,Y);d(this,Z);d(this,At);d(this,pt);d(this,wt);d(this,p);d(this,Ft);d(this,at);d(this,J);d(this,Tt);d(this,N,void 0);d(this,L,void 0);d(this,P,void 0);d(this,H,void 0);d(this,ut,void 0);d(this,dt,void 0);b(this,"ttl");b(this,"ttlResolution");b(this,"ttlAutopurge");b(this,"updateAgeOnGet");b(this,"updateAgeOnHas");b(this,"allowStale");b(this,"noDisposeOnSet");b(this,"noUpdateTTL");b(this,"maxEntrySize");b(this,"sizeCalculation");b(this,"noDeleteOnFetchRejection");b(this,"noDeleteOnStaleGet");b(this,"allowStaleOnFetchAbort");b(this,"allowStaleOnFetchRejection");b(this,"ignoreFetchAbort");d(this,T,void 0);d(this,k,void 0);d(this,F,void 0);d(this,m,void 0);d(this,g,void 0);d(this,R,void 0);d(this,x,void 0);d(this,C,void 0);d(this,O,void 0);d(this,V,void 0);d(this,E,void 0);d(this,B,void 0);d(this,$,void 0);d(this,U,void 0);d(this,q,void 0);d(this,ht,void 0);d(this,W,void 0);d(this,ot,()=>{});d(this,K,()=>{});d(this,bt,()=>{});d(this,M,()=>!1);d(this,lt,e=>{});d(this,gt,(e,i,s)=>{});d(this,yt,(e,i,s,h)=>{if(s||h)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0});b(this,Kt,"LRUCache");const{max:i=0,ttl:s,ttlResolution:h=1,ttlAutopurge:n,updateAgeOnGet:r,updateAgeOnHas:u,allowStale:l,dispose:w,disposeAfter:G,noDisposeOnSet:S,noUpdateTTL:Q,maxSize:I=0,maxEntrySize:X=0,sizeCalculation:A,fetchMethod:v,memoMethod:c,noDeleteOnFetchRejection:y,noDeleteOnStaleGet:D,allowStaleOnFetchRejection:z,allowStaleOnFetchAbort:j,ignoreFetchAbort:St}=e;if(i!==0&&!et(i))throw new TypeError("max option must be a nonnegative integer");const tt=i?qt(i):Array;if(!tt)throw new Error("invalid max value: "+i);if(a(this,N,i),a(this,L,I),this.maxEntrySize=X||t(this,L),this.sizeCalculation=A,this.sizeCalculation){if(!t(this,L)&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!="function")throw new TypeError("sizeCalculation set to non-function")}if(c!==void 0&&typeof c!="function")throw new TypeError("memoMethod must be a function if defined");if(a(this,dt,c),v!==void 0&&typeof v!="function")throw new TypeError("fetchMethod must be a function if specified");if(a(this,ut,v),a(this,ht,!!v),a(this,F,new Map),a(this,m,new Array(i).fill(void 0)),a(this,g,new Array(i).fill(void 0)),a(this,R,new tt(i)),a(this,x,new tt(i)),a(this,C,0),a(this,O,0),a(this,V,Ut.create(i)),a(this,T,0),a(this,k,0),typeof w=="function"&&a(this,P,w),typeof G=="function"?(a(this,H,G),a(this,E,[])):(a(this,H,void 0),a(this,E,void 0)),a(this,q,!!t(this,P)),a(this,W,!!t(this,H)),this.noDisposeOnSet=!!S,this.noUpdateTTL=!!Q,this.noDeleteOnFetchRejection=!!y,this.allowStaleOnFetchRejection=!!z,this.allowStaleOnFetchAbort=!!j,this.ignoreFetchAbort=!!St,this.maxEntrySize!==0){if(t(this,L)!==0&&!et(t(this,L)))throw new TypeError("maxSize must be a positive integer if specified");if(!et(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");o(this,Wt,Xt).call(this)}if(this.allowStale=!!l,this.noDeleteOnStaleGet=!!D,this.updateAgeOnGet=!!r,this.updateAgeOnHas=!!u,this.ttlResolution=et(h)||h===0?h:1,this.ttlAutopurge=!!n,this.ttl=s||0,this.ttl){if(!et(this.ttl))throw new TypeError("ttl must be a positive integer if specified");o(this,mt,Mt).call(this)}if(t(this,N)===0&&this.ttl===0&&t(this,L)===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!t(this,N)&&!t(this,L)){const Ot="LRU_CACHE_UNBOUNDED";Jt(Ot)&&(Bt.add(Ot),$t("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",Ot,Nt))}}static unsafeExposeInternals(e){return{starts:t(e,$),ttls:t(e,U),sizes:t(e,B),keyMap:t(e,F),keyList:t(e,m),valList:t(e,g),next:t(e,R),prev:t(e,x),get head(){return t(e,C)},get tail(){return t(e,O)},free:t(e,V),isBackgroundFetch:i=>{var s;return o(s=e,p,_).call(s,i)},backgroundFetch:(i,s,h,n)=>{var r;return o(r=e,wt,Ct).call(r,i,s,h,n)},moveToTail:i=>{var s;return o(s=e,at,_t).call(s,i)},indexes:i=>{var s;return o(s=e,Y,it).call(s,i)},rindexes:i=>{var s;return o(s=e,Z,st).call(s,i)},isStale:i=>{var s;return t(s=e,M).call(s,i)}}}get max(){return t(this,N)}get maxSize(){return t(this,L)}get calculatedSize(){return t(this,k)}get size(){return t(this,T)}get fetchMethod(){return t(this,ut)}get memoMethod(){return t(this,dt)}get dispose(){return t(this,P)}get disposeAfter(){return t(this,H)}getRemainingTTL(e){return t(this,F).has(e)?1/0:0}*entries(){for(const e of o(this,Y,it).call(this))t(this,g)[e]!==void 0&&t(this,m)[e]!==void 0&&!o(this,p,_).call(this,t(this,g)[e])&&(yield[t(this,m)[e],t(this,g)[e]])}*rentries(){for(const e of o(this,Z,st).call(this))t(this,g)[e]!==void 0&&t(this,m)[e]!==void 0&&!o(this,p,_).call(this,t(this,g)[e])&&(yield[t(this,m)[e],t(this,g)[e]])}*keys(){for(const e of o(this,Y,it).call(this)){const i=t(this,m)[e];i!==void 0&&!o(this,p,_).call(this,t(this,g)[e])&&(yield i)}}*rkeys(){for(const e of o(this,Z,st).call(this)){const i=t(this,m)[e];i!==void 0&&!o(this,p,_).call(this,t(this,g)[e])&&(yield i)}}*values(){for(const e of o(this,Y,it).call(this))t(this,g)[e]!==void 0&&!o(this,p,_).call(this,t(this,g)[e])&&(yield t(this,g)[e])}*rvalues(){for(const e of o(this,Z,st).call(this))t(this,g)[e]!==void 0&&!o(this,p,_).call(this,t(this,g)[e])&&(yield t(this,g)[e])}[Symbol.iterator](){return this.entries()}find(e,i={}){for(const s of o(this,Y,it).call(this)){const h=t(this,g)[s],n=o(this,p,_).call(this,h)?h.__staleWhileFetching:h;if(n!==void 0&&e(n,t(this,m)[s],this))return this.get(t(this,m)[s],i)}}forEach(e,i=this){for(const s of o(this,Y,it).call(this)){const h=t(this,g)[s],n=o(this,p,_).call(this,h)?h.__staleWhileFetching:h;n!==void 0&&e.call(i,n,t(this,m)[s],this)}}rforEach(e,i=this){for(const s of o(this,Z,st).call(this)){const h=t(this,g)[s],n=o(this,p,_).call(this,h)?h.__staleWhileFetching:h;n!==void 0&&e.call(i,n,t(this,m)[s],this)}}purgeStale(){let e=!1;for(const i of o(this,Z,st).call(this,{allowStale:!0}))t(this,M).call(this,i)&&(o(this,J,nt).call(this,t(this,m)[i],"expire"),e=!0);return e}info(e){const i=t(this,F).get(e);if(i===void 0)return;const s=t(this,g)[i],h=o(this,p,_).call(this,s)?s.__staleWhileFetching:s;if(h===void 0)return;const n={value:h};if(t(this,U)&&t(this,$)){const r=t(this,U)[i],u=t(this,$)[i];if(r&&u){const l=r-(ft.now()-u);n.ttl=l,n.start=Date.now()}}return t(this,B)&&(n.size=t(this,B)[i]),n}dump(){const e=[];for(const i of o(this,Y,it).call(this,{allowStale:!0})){const s=t(this,m)[i],h=t(this,g)[i],n=o(this,p,_).call(this,h)?h.__staleWhileFetching:h;if(n===void 0||s===void 0)continue;const r={value:n};if(t(this,U)&&t(this,$)){r.ttl=t(this,U)[i];const u=ft.now()-t(this,$)[i];r.start=Math.floor(Date.now()-u)}t(this,B)&&(r.size=t(this,B)[i]),e.unshift([s,r])}return e}load(e){this.clear();for(const[i,s]of e){if(s.start){const h=Date.now()-s.start;s.start=ft.now()-h}this.set(i,s.value,s)}}set(e,i,s={}){var Q,I,X,A,v;if(i===void 0)return this.delete(e),this;const{ttl:h=this.ttl,start:n,noDisposeOnSet:r=this.noDisposeOnSet,sizeCalculation:u=this.sizeCalculation,status:l}=s;let{noUpdateTTL:w=this.noUpdateTTL}=s;const G=t(this,yt).call(this,e,i,s.size||0,u);if(this.maxEntrySize&&G>this.maxEntrySize)return l&&(l.set="miss",l.maxEntrySizeExceeded=!0),o(this,J,nt).call(this,e,"set"),this;let S=t(this,T)===0?void 0:t(this,F).get(e);if(S===void 0)S=t(this,T)===0?t(this,O):t(this,V).length!==0?t(this,V).pop():t(this,T)===t(this,N)?o(this,pt,vt).call(this,!1):t(this,T),t(this,m)[S]=e,t(this,g)[S]=i,t(this,F).set(e,S),t(this,R)[t(this,O)]=S,t(this,x)[S]=t(this,O),a(this,O,S),Et(this,T)._++,t(this,gt).call(this,S,G,l),l&&(l.set="add"),w=!1;else{o(this,at,_t).call(this,S);const c=t(this,g)[S];if(i!==c){if(t(this,ht)&&o(this,p,_).call(this,c)){c.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:y}=c;y!==void 0&&!r&&(t(this,q)&&((Q=t(this,P))==null||Q.call(this,y,e,"set")),t(this,W)&&((I=t(this,E))==null||I.push([y,e,"set"])))}else r||(t(this,q)&&((X=t(this,P))==null||X.call(this,c,e,"set")),t(this,W)&&((A=t(this,E))==null||A.push([c,e,"set"])));if(t(this,lt).call(this,S),t(this,gt).call(this,S,G,l),t(this,g)[S]=i,l){l.set="replace";const y=c&&o(this,p,_).call(this,c)?c.__staleWhileFetching:c;y!==void 0&&(l.oldValue=y)}}else l&&(l.set="update")}if(h!==0&&!t(this,U)&&o(this,mt,Mt).call(this),t(this,U)&&(w||t(this,bt).call(this,S,h,n),l&&t(this,K).call(this,l,S)),!r&&t(this,W)&&t(this,E)){const c=t(this,E);let y;for(;y=c==null?void 0:c.shift();)(v=t(this,H))==null||v.call(this,...y)}return this}pop(){var e;try{for(;t(this,T);){const i=t(this,g)[t(this,C)];if(o(this,pt,vt).call(this,!0),o(this,p,_).call(this,i)){if(i.__staleWhileFetching)return i.__staleWhileFetching}else if(i!==void 0)return i}}finally{if(t(this,W)&&t(this,E)){const i=t(this,E);let s;for(;s=i==null?void 0:i.shift();)(e=t(this,H))==null||e.call(this,...s)}}}has(e,i={}){const{updateAgeOnHas:s=this.updateAgeOnHas,status:h}=i,n=t(this,F).get(e);if(n!==void 0){const r=t(this,g)[n];if(o(this,p,_).call(this,r)&&r.__staleWhileFetching===void 0)return!1;if(t(this,M).call(this,n))h&&(h.has="stale",t(this,K).call(this,h,n));else return s&&t(this,ot).call(this,n),h&&(h.has="hit",t(this,K).call(this,h,n)),!0}else h&&(h.has="miss");return!1}peek(e,i={}){const{allowStale:s=this.allowStale}=i,h=t(this,F).get(e);if(h===void 0||!s&&t(this,M).call(this,h))return;const n=t(this,g)[h];return o(this,p,_).call(this,n)?n.__staleWhileFetching:n}async fetch(e,i={}){const{allowStale:s=this.allowStale,updateAgeOnGet:h=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,ttl:r=this.ttl,noDisposeOnSet:u=this.noDisposeOnSet,size:l=0,sizeCalculation:w=this.sizeCalculation,noUpdateTTL:G=this.noUpdateTTL,noDeleteOnFetchRejection:S=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:Q=this.allowStaleOnFetchRejection,ignoreFetchAbort:I=this.ignoreFetchAbort,allowStaleOnFetchAbort:X=this.allowStaleOnFetchAbort,context:A,forceRefresh:v=!1,status:c,signal:y}=i;if(!t(this,ht))return c&&(c.fetch="get"),this.get(e,{allowStale:s,updateAgeOnGet:h,noDeleteOnStaleGet:n,status:c});const D={allowStale:s,updateAgeOnGet:h,noDeleteOnStaleGet:n,ttl:r,noDisposeOnSet:u,size:l,sizeCalculation:w,noUpdateTTL:G,noDeleteOnFetchRejection:S,allowStaleOnFetchRejection:Q,allowStaleOnFetchAbort:X,ignoreFetchAbort:I,status:c,signal:y};let z=t(this,F).get(e);if(z===void 0){c&&(c.fetch="miss");const j=o(this,wt,Ct).call(this,e,z,D,A);return j.__returned=j}else{const j=t(this,g)[z];if(o(this,p,_).call(this,j)){const Pt=s&&j.__staleWhileFetching!==void 0;return c&&(c.fetch="inflight",Pt&&(c.returnedStale=!0)),Pt?j.__staleWhileFetching:j.__returned=j}const St=t(this,M).call(this,z);if(!v&&!St)return c&&(c.fetch="hit"),o(this,at,_t).call(this,z),h&&t(this,ot).call(this,z),c&&t(this,K).call(this,c,z),j;const tt=o(this,wt,Ct).call(this,e,z,D,A),Dt=tt.__staleWhileFetching!==void 0&&s;return c&&(c.fetch=St?"stale":"refresh",Dt&&St&&(c.returnedStale=!0)),Dt?tt.__staleWhileFetching:tt.__returned=tt}}async forceFetch(e,i={}){const s=await this.fetch(e,i);if(s===void 0)throw new Error("fetch() returned undefined");return s}memo(e,i={}){const s=t(this,dt);if(!s)throw new Error("no memoMethod provided to constructor");const{context:h,forceRefresh:n,...r}=i,u=this.get(e,r);if(!n&&u!==void 0)return u;const l=s(e,u,{options:r,context:h});return this.set(e,l,r),l}get(e,i={}){const{allowStale:s=this.allowStale,updateAgeOnGet:h=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,status:r}=i,u=t(this,F).get(e);if(u!==void 0){const l=t(this,g)[u],w=o(this,p,_).call(this,l);return r&&t(this,K).call(this,r,u),t(this,M).call(this,u)?(r&&(r.get="stale"),w?(r&&s&&l.__staleWhileFetching!==void 0&&(r.returnedStale=!0),s?l.__staleWhileFetching:void 0):(n||o(this,J,nt).call(this,e,"expire"),r&&s&&(r.returnedStale=!0),s?l:void 0)):(r&&(r.get="hit"),w?l.__staleWhileFetching:(o(this,at,_t).call(this,u),h&&t(this,ot).call(this,u),l))}else r&&(r.get="miss")}delete(e){return o(this,J,nt).call(this,e,"delete")}clear(){return o(this,Tt,jt).call(this,"delete")}};Kt=Symbol.toStringTag,N=new WeakMap,L=new WeakMap,P=new WeakMap,H=new WeakMap,ut=new WeakMap,dt=new WeakMap,T=new WeakMap,k=new WeakMap,F=new WeakMap,m=new WeakMap,g=new WeakMap,R=new WeakMap,x=new WeakMap,C=new WeakMap,O=new WeakMap,V=new WeakMap,E=new WeakMap,B=new WeakMap,$=new WeakMap,U=new WeakMap,q=new WeakMap,ht=new WeakMap,W=new WeakMap,mt=new WeakSet,Mt=function(){const e=new zt(t(this,N)),i=new zt(t(this,N));a(this,U,e),a(this,$,i),a(this,bt,(n,r,u=ft.now())=>{if(i[n]=r!==0?u:0,e[n]=r,r!==0&&this.ttlAutopurge){const l=setTimeout(()=>{t(this,M).call(this,n)&&o(this,J,nt).call(this,t(this,m)[n],"expire")},r+1);l.unref&&l.unref()}}),a(this,ot,n=>{i[n]=e[n]!==0?ft.now():0}),a(this,K,(n,r)=>{if(e[r]){const u=e[r],l=i[r];if(!u||!l)return;n.ttl=u,n.start=l,n.now=s||h();const w=n.now-l;n.remainingTTL=u-w}});let s=0;const h=()=>{const n=ft.now();if(this.ttlResolution>0){s=n;const r=setTimeout(()=>s=0,this.ttlResolution);r.unref&&r.unref()}return n};this.getRemainingTTL=n=>{const r=t(this,F).get(n);if(r===void 0)return 0;const u=e[r],l=i[r];if(!u||!l)return 1/0;const w=(s||h())-l;return u-w},a(this,M,n=>{const r=i[n],u=e[n];return!!u&&!!r&&(s||h())-r>u})},ot=new WeakMap,K=new WeakMap,bt=new WeakMap,M=new WeakMap,Wt=new WeakSet,Xt=function(){const e=new zt(t(this,N));a(this,k,0),a(this,B,e),a(this,lt,i=>{a(this,k,t(this,k)-e[i]),e[i]=0}),a(this,yt,(i,s,h,n)=>{if(o(this,p,_).call(this,s))return 0;if(!et(h))if(n){if(typeof n!="function")throw new TypeError("sizeCalculation must be a function");if(h=n(s,i),!et(h))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return h}),a(this,gt,(i,s,h)=>{if(e[i]=s,t(this,L)){const n=t(this,L)-e[i];for(;t(this,k)>n;)o(this,pt,vt).call(this,!0)}a(this,k,t(this,k)+e[i]),h&&(h.entrySize=s,h.totalCalculatedSize=t(this,k))})},lt=new WeakMap,gt=new WeakMap,yt=new WeakMap,Y=new WeakSet,it=function*({allowStale:e=this.allowStale}={}){if(t(this,T))for(let i=t(this,O);!(!o(this,At,Gt).call(this,i)||((e||!t(this,M).call(this,i))&&(yield i),i===t(this,C)));)i=t(this,x)[i]},Z=new WeakSet,st=function*({allowStale:e=this.allowStale}={}){if(t(this,T))for(let i=t(this,C);!(!o(this,At,Gt).call(this,i)||((e||!t(this,M).call(this,i))&&(yield i),i===t(this,O)));)i=t(this,R)[i]},At=new WeakSet,Gt=function(e){return e!==void 0&&t(this,F).get(t(this,m)[e])===e},pt=new WeakSet,vt=function(e){var n,r;const i=t(this,C),s=t(this,m)[i],h=t(this,g)[i];return t(this,ht)&&o(this,p,_).call(this,h)?h.__abortController.abort(new Error("evicted")):(t(this,q)||t(this,W))&&(t(this,q)&&((n=t(this,P))==null||n.call(this,h,s,"evict")),t(this,W)&&((r=t(this,E))==null||r.push([h,s,"evict"]))),t(this,lt).call(this,i),e&&(t(this,m)[i]=void 0,t(this,g)[i]=void 0,t(this,V).push(i)),t(this,T)===1?(a(this,C,a(this,O,0)),t(this,V).length=0):a(this,C,t(this,R)[i]),t(this,F).delete(s),Et(this,T)._--,i},wt=new WeakSet,Ct=function(e,i,s,h){const n=i===void 0?void 0:t(this,g)[i];if(o(this,p,_).call(this,n))return n;const r=new Rt,{signal:u}=s;u==null||u.addEventListener("abort",()=>r.abort(u.reason),{signal:r.signal});const l={signal:r.signal,options:s,context:h},w=(A,v=!1)=>{const{aborted:c}=r.signal,y=s.ignoreFetchAbort&&A!==void 0;if(s.status&&(c&&!v?(s.status.fetchAborted=!0,s.status.fetchError=r.signal.reason,y&&(s.status.fetchAbortIgnored=!0)):s.status.fetchResolved=!0),c&&!y&&!v)return S(r.signal.reason);const D=I;return t(this,g)[i]===I&&(A===void 0?D.__staleWhileFetching?t(this,g)[i]=D.__staleWhileFetching:o(this,J,nt).call(this,e,"fetch"):(s.status&&(s.status.fetchUpdated=!0),this.set(e,A,l.options))),A},G=A=>(s.status&&(s.status.fetchRejected=!0,s.status.fetchError=A),S(A)),S=A=>{const{aborted:v}=r.signal,c=v&&s.allowStaleOnFetchAbort,y=c||s.allowStaleOnFetchRejection,D=y||s.noDeleteOnFetchRejection,z=I;if(t(this,g)[i]===I&&(!D||z.__staleWhileFetching===void 0?o(this,J,nt).call(this,e,"fetch"):c||(t(this,g)[i]=z.__staleWhileFetching)),y)return s.status&&z.__staleWhileFetching!==void 0&&(s.status.returnedStale=!0),z.__staleWhileFetching;if(z.__returned===z)throw A},Q=(A,v)=>{var y;const c=(y=t(this,ut))==null?void 0:y.call(this,e,n,l);c&&c instanceof Promise&&c.then(D=>A(D===void 0?void 0:D),v),r.signal.addEventListener("abort",()=>{(!s.ignoreFetchAbort||s.allowStaleOnFetchAbort)&&(A(void 0),s.allowStaleOnFetchAbort&&(A=D=>w(D,!0)))})};s.status&&(s.status.fetchDispatched=!0);const I=new Promise(Q).then(w,G),X=Object.assign(I,{__abortController:r,__staleWhileFetching:n,__returned:void 0});return i===void 0?(this.set(e,X,{...l.options,status:void 0}),i=t(this,F).get(e)):t(this,g)[i]=X,X},p=new WeakSet,_=function(e){if(!t(this,ht))return!1;const i=e;return!!i&&i instanceof Promise&&i.hasOwnProperty("__staleWhileFetching")&&i.__abortController instanceof Rt},Ft=new WeakSet,It=function(e,i){t(this,x)[i]=e,t(this,R)[e]=i},at=new WeakSet,_t=function(e){e!==t(this,O)&&(e===t(this,C)?a(this,C,t(this,R)[e]):o(this,Ft,It).call(this,t(this,x)[e],t(this,R)[e]),o(this,Ft,It).call(this,t(this,O),e),a(this,O,e))},J=new WeakSet,nt=function(e,i){var h,n,r,u;let s=!1;if(t(this,T)!==0){const l=t(this,F).get(e);if(l!==void 0)if(s=!0,t(this,T)===1)o(this,Tt,jt).call(this,i);else{t(this,lt).call(this,l);const w=t(this,g)[l];if(o(this,p,_).call(this,w)?w.__abortController.abort(new Error("deleted")):(t(this,q)||t(this,W))&&(t(this,q)&&((h=t(this,P))==null||h.call(this,w,e,i)),t(this,W)&&((n=t(this,E))==null||n.push([w,e,i]))),t(this,F).delete(e),t(this,m)[l]=void 0,t(this,g)[l]=void 0,l===t(this,O))a(this,O,t(this,x)[l]);else if(l===t(this,C))a(this,C,t(this,R)[l]);else{const G=t(this,x)[l];t(this,R)[G]=t(this,R)[l];const S=t(this,R)[l];t(this,x)[S]=t(this,x)[l]}Et(this,T)._--,t(this,V).push(l)}}if(t(this,W)&&((r=t(this,E))!=null&&r.length)){const l=t(this,E);let w;for(;w=l==null?void 0:l.shift();)(u=t(this,H))==null||u.call(this,...w)}return s},Tt=new WeakSet,jt=function(e){var i,s,h;for(const n of o(this,Z,st).call(this,{allowStale:!0})){const r=t(this,g)[n];if(o(this,p,_).call(this,r))r.__abortController.abort(new Error("deleted"));else{const u=t(this,m)[n];t(this,q)&&((i=t(this,P))==null||i.call(this,r,u,e)),t(this,W)&&((s=t(this,E))==null||s.push([r,u,e]))}}if(t(this,F).clear(),t(this,g).fill(void 0),t(this,m).fill(void 0),t(this,U)&&t(this,$)&&(t(this,U).fill(0),t(this,$).fill(0)),t(this,B)&&t(this,B).fill(0),a(this,C,0),a(this,O,0),t(this,V).length=0,a(this,k,0),a(this,T,0),t(this,W)&&t(this,E)){const n=t(this,E);let r;for(;r=n==null?void 0:n.shift();)(h=t(this,H))==null||h.call(this,...r)}};let kt=Nt;export{kt as L};
